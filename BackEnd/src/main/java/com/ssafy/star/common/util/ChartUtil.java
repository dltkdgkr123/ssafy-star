package com.ssafy.star.common.util;

import java.util.Arrays;
import java.util.List;

public class ChartUtil {

    public List<String[]> getSaying() {

        return Arrays.asList(new String[]{"자동차가 컴퓨터와 같은 개발공정을 따랐다면, 롤스로이스는 100달러쯤에 살 수 있고 연비도 백만마일 정도 될거다. 하지만 일년에 한 번씩 폭발해 버리는 살인머신이 되어버릴거다.", "Robert X. Cringely, 테크 저널리스트"},
                new String[]{"오늘날 대부분의 소프트웨어는 구조적 고민없이 그냥 벽돌 한장씩 쌓아올린 피라미드 같다. 더구나 수천 만의 노예와 폭력들로 쌓아 올려졌다.", "Alan Kay, 객체지향 프로그래밍의 아버지"},
                new String[]{"진정한 혁신이란 시장을 만들 수는 있지만, 소유할 힘은 없는 작은 스타트업으로부터 일어난다.", "Timm Martin, 게임 개발자"},
                new String[]{"이것은 bit, bytes, protocol에 대한 것이 아니다. 이익과 손실, 그리고 마진에 대한 것이다.", "Lou Gerstner, 맥킨지 CEO"},
                new String[]{"소프트웨어 설계를 하는 두 가지 방법이 있다. 하나는 빠진 게 없는지 쉽게 확인할 수 있도록 최대한 단순하게 만드는 것이고, 또 한가지는 빠진 게 없는지 확인할 수 없도록 최대한 복잡하게 만드는 것이다.", "C.A.R. Hoare, Quick Sort의 고안자"},
                new String[]{"좋은 소프트웨어의 기능이란 복잡한 것을 간단하게 보이도록 만드는 것이다.", "Grady Booch, UML 개발자"},
                new String[]{"우리는 프로그래머 3대 미덕을 잘 알고 있다. – 게으름, 괴팍함, 그리고 자만심.", "Larry Wall, Perl 언어의 창시자"},
                new String[]{"프로그래머의 문제점은 일이 너무 늦어질 때까지, 뭘하고 있는지 절대 물어볼 수 없다는 점이다.", "Seymour Cray, 슈퍼컴퓨터 크레이를 만든 사람"},
                new String[]{"붓과 색을 공부한다고 훌륭한 화가가 되지 않듯, 컴퓨터과학을 공부한다고 훌륭한 프로그래머가 되지는 않는다.", "Eric Raymond, 인류학자, 오픈소스 운동의 대표 서술가"},
                new String[]{"해커란 7,8명의 개발자들이 1년 동안 어렵게 개발하는 것들을 단 몇달 만에 혼자서 개발할 수 있는 사람을 말한다. IBM은 어떤 프로그래머들은 다른 이들보다 100배 이상의 더 많은 일을 할 수 있다고  보고했었다.", "Peter Seebach, Unix 전문 테크 저널리스트"},
                new String[]{"훌륭한 기계공은 일반 기계공보다 몇배의 급여를 더 높이 받는다. 그러나 훌륭한 코드를 만들어내는 개발자는 일반적인 개발자보다 1만배 이상의 가치가 있다.", "Bill Gates"},
                new String[]{"코드 수를 기준으로 프로그램의 진도를 측정하는 것은 비행기 제작 진도를 무게로 측정하는 것과 같다.", "Bill Gates"},
                new String[]{"처음에는 컴퓨터 과학과 이론을 배워라. 그리고는 프로그래밍 스타일을 익혀라. 그리고는 모두 잊어버려라. 그저 해킹하라. - hack은 개발에 몰두하는 것을 말함", "George Carrette, SIOD의 창시자"},
                new String[]{"먼저 문제를 풀고 그 다음에 개발을 하라.", "John Johnson, 미국의 유명한 소프트웨어 강사"},
                new String[]{"사람은 반복문을 쓰고, 신은 재귀함수를 쓴다.", "L. Peter Deutsch, PDF Interpreter, Ghostscript, PostScript의 창시자"},
                new String[]{"Boolean 이 좋은 것은 당신이 설령 잘못했더라도 한 bit만 바꾸면 된다는 것이다.", "개발자 속담"},
                new String[]{"Array는 꼭 0이나 1에서 시작해야 하나? 내 생각에는 0.5 에서 시작하면 어떨까? … 라는 내 의견은 충분한 검토 없이 기각된 것 같다.", "Stan Kelly-Bootle, 컴퓨터과학자"},
                new String[]{"세상에는 딱 두 가지 프로그래밍 언어가 있다. 사람들이 욕하는 언어와 아무도 사용하지 않는 언어.", "Bjarne Stroustrup, C++의 창시자"},
                new String[]{"내 생각에 MS가 .Net 이라고 이름을 붙인 이유는 유닉스 상에서 이 폴더가 안 보이게 하고 싶었던 거다.", "Oktal"},
                new String[]{"BASIC을 먼저 배운 학생들에게 좋은 프로그래밍 스타일을 가르친다는 건 현실적으로 불가능하다. 그들의 마음은 회복할 수 없는 피해를 입은 것과 같다.", "E. W. Dijkstra, 상동"},
                new String[]{"아무리 구조가 잘 되어 있더라도, 프로그래머가 나쁜 프로그램을 만드는 걸 막아주는 프로그래밍 언어는 없다.", "Larry Flon, 구조적 프로그래밍에 대한 연구 저자"},
                new String[]{"컴퓨터 언어를 설계하는 건 공원을 산책하는 것과 같다. “쥬라기 공원!!!”", "Larry Wall, Perl 언어의 창시자"},
                new String[]{"C,C++을 쓰는 건 안전가드를 제거한 전기톱을 쓰는 것과 같다.", "Bob Gray"},
                new String[]{"C++ 에서는 스스로 발을 쏘는 행위는 거의 일어나지 않는다. 하지만 그런 일이 일어난다면 다리 전체를 날려버리게 된다.", "Bjarne Stroustrup, C++언어의 창시자"},
                new String[]{"로마제국이 멸망한 이유 중 하나는 0 이 없었기 때문이다. 그들은 C 프로그램의 종료를 제대로 표시할 방법이 없었다.", "Robert Firth"},
                new String[]{"C++ : 여기선 친구들이 당신의 private members에 접근할 수 있다.", "Gavin Russell Baker"},
                new String[]{"자바는 많은 부분에서 C++- (C 플플 마이너스) 이다.", "Michael Feldman, SIGAda 의장"},
                new String[]{"맞아요. 자바는 프로그래밍 언어가 보여줄 수 있는 아주 좋은 사례입니다. 그러나 자바 어플리케이션은 절대 그렇게 만들지 말아야 하는 아주 좋은 사례입니다.", "pixadel"},
                new String[]{"자바가 정말로 Garbage collection 을 한다면, 대부분의 프로그램들은 실행 중에 자기 자신을 지워버릴지도 모른다.", "Robert Sewell"},
                new String[]{"무료 소프트웨어를 두려워하는 사람들은 자신들의 제품이 그것보다 못하기 때문이다.", "David Emery, 오픈소스 개발자"},
                new String[]{"훌륭한 코드는 훌륭한 문서보다 낫다.", "Steve McConnell, 개발자"},
                new String[]{"당신이 6개월 이상 한 번도 보지 않은 코드는 다른 사람이 다시 만드는 게 훨씬 더 나을 수 있다.", "Eagleson’s Law"},
                new String[]{"코드의 90%는 개발 시간의 90%를 설명해준다. 나머지 10%는 그 시간에 일어났던 다른 일의  90%를 설명해준다.", "Tom Cargill, 벨연구소 개발자"},
                new String[]{"소프트웨어에는 사실 의미있는 것들이 거의 없다. 만일 그런 게 있다고 할지라도, 유일한 성공척도는 고객들이 뭐가 문제인지 몰라 갈팡질팡하는 걸 도와주었냐 하는 것이다.", "Jeff Atwood, StackOverFlow의 창립자"},
                new String[]{"좋은 프로그래머는 자기 두뇌를 사용한다. 그러나 좋은 가이드라인은 모든 케이스를 고려해야만 하는 노력을 줄여준다.", "Francis Glassborow, 개발자"},
                new String[]{"훌륭한 개발팀 없이 훌륭한 소프트웨어를 만들 수는 없다. 그러나 대부분의 개발팀은 문제 있는 가족들처럼 행동한다.", "Jim McCarthy, AI 용어를 만든사람, 인지 과학자"},
                new String[]{"우리는 프로그래밍을 시작하자 마자 생각했던 대로  만들기 쉽지 않다는 것에 놀라게 된다. 그래서 디버깅이 만들어졌다. 나는 인생의 대부분이 내 프로그램의 실수를 찾아내는데 낭비되고 있음을 알게 된 때를 정확히 기억한다.", "Maurice Wilkes, EDSAC과 마이크로프로그래밍의 창시자"},
                new String[]{"디버깅은 코드를 새로 만드는 것보다 두 배 더 어렵다. 그래서 만일 당신이 현재 공들여서 코드를 짜고 있다면, 디버깅할만큼 똑똑하지 않다는 뜻이기도 하다.", "Brian Kernighan, Unix 창시자"},
                new String[]{"만일 디버깅이 벌레를 잡는 과정이라면, 프로그래밍은 그걸 집어넣는 과정이다.", "Edsger W. Dijkstra, 구조적 프로그래밍/세마포어로 유명한 컴퓨터 과학자"},
                new String[]{"당신의 컴퓨터에서 돌아가는 건 중요하지 않다. 당신의 컴퓨터로 서비스하는 게 아니기 때문이다.", "Vidiu Platon"},
                new String[]{"에러 없는 프로그램을 만드는 데는 두가지 방법이 있다. 그런데  세번째 것만 작동한다.", "Alan J. Perlis, 알골 프로그램 창시자"},
                new String[]{"당신은 소프트웨어 품질을 추구할 수도 있고, 포인터 연산을 할 수도 있다. 그러나 두 개를 동시에 할 수는 없다.", "Bertrand Meyer, 에펠 언어의 창시자"},
                new String[]{"만일 소프트웨어회사가 맥도날드라면, 수백개의 빅맥 중 하나가 식중독을 일으킬 때 아마 이렇게 말할 것이다. “죄송합니다. 고객님. 여기 쿠폰 두 장을 받으세요…”", "Mark Minasi, 윈도우 개발계의 대부"},
                new String[]{"항상 이런 생각으로 개발에 임하라. “내 소스를 유지보수하게 될 개발자는 내가 어디 살고 있는지 알고 싶어하는 과격한 사이코패스일 것이다.”", "Martin Golding"},
                new String[]{"실수는 사람의 것이다. 그러나 정말 일을 엉망으로 만들고 싶다면 컴퓨터가 필요하다.", "Paul Ehrlich"},
                new String[]{"컴퓨터는 그동안 인류 역사에서 발명했던 그 어떠한 것들 보다 더 빠르고 더 많은 실수들을 사람들이 하게 만든다. 권총과 데낄라를 제외하고서,", "Mitch Radcliffe"},
                new String[]{"이대로라면 사람들의 근육은 퇴화해버려서 버튼을 누를 손가락만 남을 것이다.", "Frank Lloyd Wright"},
                new String[]{"좋은 디자인은 그 때문에 소모되는 비용보다 빠르게 가치가 쌓인다.", "Thomas C. Gale, 미국의 자동차 디자이너"},
                new String[]{"디버깅한번 으로 천버그 잡는다.", "개발자 속어"},
                new String[]{"어떤 바보라도 컴퓨터를 사용할 수 있다. 그래서 많은 사람들이 컴퓨터를 사용한다.", "Ted Nelson, HTML을 만든 사회 과학자"},
                new String[]{"바보는 복잡한 것을 무시하고, 현실주의자는 괴로워하며, 피하기도 한다. 하지만 천재는 복잡한 것을 없애버린다.", "Alan J. Perlis, 알골 프로그램 창시자"},
                new String[]{"어떤 면에서 프로그래밍은 그림그리는 것과 같다. 당신은 특정한 기본 재료들과 하얀 캔버스에서 시작한다. 그것들을 가지고 무엇을 할지 결정하기 위해서 당신은 과학, 기술, 기예의 조합을 사용한다.", "Andrew Hunt, The Pragmatic Programmer 의 저자"},
                new String[]{"시스템에는 서브시스템이 있고, 서브시스템에는 또 서브시스템이 있고, 이런 형식이 무한대로 반복되기 때문에 우리는 언제나 시작점에 서 있는 것이다.", "Alan J. Perlis, 알골 프로그램 창시자"},
                new String[]{"소프트웨어 데모가 아무리 매끄럽다고 하더라도, 완벽한 프리젠테이션을 할 확률은 지켜보는 사람의 숫자에 반비례 하며 투입되는 돈에 정비례 한다.", "Mark Gibbs, 저널리스트"},
                new String[]{"소프트웨어 설계를 구성하는 데에는 두 가지 방법이 있다. 한가지 방법은 아주 단순하게 만들어서 명백히 결함이 없게 된다. 그리고 다른 방법은 너무 복잡하게 만들어서 명백한 결함이 없게 된다.", "Sir Tony Hoare, Quick Sort의 고안자"},
                new String[]{"소프트웨어를 디자인할 때는 나는 건축가 이다. 유저 인터페이스를 디자인할 때는 예술가이며, 구현할 때는 장인이 된다. 하지만 테스트를 할 때는 아마 쳐죽일 놈이 될 것이다.", "Steve McConnell, Construx Software Builders사의 CEO"},
                new String[]{"올바로 동작하지 않더라도 걱정말아라. 모든 것이 그랬다면, 넌 직업을 잃었을테니까.", "모셔의 법칙"},
                new String[]{"위 코드의 버그를 조심하라. 올바르다고 증명하기만 하고 실행해 보지는 않았다.", "Donald E. Knuth, 알고리즘 분석 분야 창조자"},
                new String[]{"우리는 조그마한 효율성에 대해 고민할 필요가 없다. 대략 97%의 경우, 어설픈 최적화는 모든 악의 근원이라 말하고 싶다.", "Knuth Donald, 스탠퍼드 대학교의 명예교수"},
                new String[]{"파이썬이 베이직과 동급이라면 옵티머스 프라임은 트럭이다.", "Cory Dodt"},
                new String[]{"개발자 망신은 Copy&Paste가 시킨다.", "개발자 속어"},
                new String[]{"새로운 프로그래밍 언어를 배우는 유일한 방법은 그 언어로 프로그램을 만드는 것이다.", "Dennis Ritchie, C언어의 창시자"},
                new String[]{"많은 프로젝트의 성공과 실패는 어떻게 수행하는가보다 누가 수행하는가에 따라 결정된다.", "Robert L. Glass, 유명한 미국 소프트웨어 엔지니어 및 작가"},
                new String[]{"대부분의 프로젝트는 기술이 아니라 인적 자원과 프로젝트 관리의 문제로 실패한다.", "R. Thomsett, 1989년 호주 컴퓨터 학회 올해의 강사"},
                new String[]{"매주 목요일마다 당신이 항상 하던대로 신발끈을 묶으면 신발이 폭발한다고 생각해보라. 컴퓨터를 사용할 때는 이런 일이 항상 일어나는데도 아무도 불평할 생각을 안 한다.", "Jef Raskin, Mac의 아버지"},
                new String[]{"게으름이 자신의 가장 좋은 친구이다. 한 번에 자동화할 수 있는 것을 두 번 하지 마라.", "개발자 속어"},
                new String[]{"내가 ‘객체 지향’이란 용어를 고안했으니 말인데, C++를 염두에 두진 않았다고 말할 수 있다.", "Alan Kay, 객체지향 프로그래밍의 아버지"},
                new String[]{"다시 작성하라. 유지 관리가 불가능한 레거시 코드를 위한 패치는 존재하지 않는다.", "개발자 속어"},
                new String[]{"컴퓨터의 비인간성 중 일부는 일단 완벽하게 프로그래밍되어 제대로 돌아가면 완전히 정직하다는 것이다.", "Isaac Asimov, 미국의 작가"},
                new String[]{"처음 시작은 초라했습니다. 제가 만든 프로그램은 사용자가 좋아하는 색깔이 뭔지, 나아가 몇살인지 물어보는 프로그램이었습니다.", "Andrew W Houston, 드롭박스 창업자"});
    }

    public List<String[]> getCs() {
        return Arrays.asList(new String[]{"OSI 7 계층에서 데이터를 전기적, 광적 신호로 변환하여 전송하는 계층은?", "물리 계층"},
                new String[]{"IP 주소 클래스 중 A 클래스의 첫 번째 바이트의 범위는?", "0~127"},
                new String[]{"#1는 연결 지향적이고 신뢰성 있는 데이터 전송을 보장하며, #2는 비연결 지향적이고 신뢰성 없는 데이터 전송을 수행한다.", "TCP/UDP"},
                new String[]{"멀티태스킹은 하나의 #1에서 여러 작업을 동시에 처리하는 것이고, 멀티프로세싱은 여러 개의 #1를 사용하여 여러 작업을 동시에 처리하는 것이다.", "CPU"},
                new String[]{"#1는 여러 프로세스 또는 스레드 간의 공유자원 접근을 제어하기 위한 동기화 도구이며, #2는 공유자원에 대한 단독 접근을 보장하기 위한 동기화 도구이다.", "세마포어/뮤텍스"},
                new String[]{"#1는 독립적으로 메모리 공간을 가지며 실행되는 프로그램 단위이고, #2는 그 안에서 동작하는 실행 단위이다.", "프로세스/스레드"},
                new String[]{"웹 서비스를 구현하기 위한 아키텍처 패턴으로, HTTP를 통해 자원을 주고 받는 웹 API 디자인 규칙은?", "RESTful API"},
                new String[]{"MVC 디자인 패턴에서, #1은 데이터를 처리하고 저장하는 역할을 하며, #2는 사용자 인터페이스를 표시하는 역할을 하며, #3는 #1과 #2를 제어하고 상호작용을 조정하는 역할을 한다.", "Model/View/Controller"},
                new String[]{"#1는 자주 사용되는 데이터를 메모리에 미리 저장하여 데이터 접근 시간을 줄이는 방식으로 동작한다.", "Cache"},
                new String[]{"브라우저의 페이지 전체를 다시 로드하지 않고 비동기적으로 서버와 데이터를 주고 받는 방식은?", "AJAX"},
                new String[]{"#1은 정렬된 배열에서 특정한 값을 찾는 알고리즘으로, 배열의 중간값을 선택하여 찾고자 하는 값과 비교하여 찾는 값을 좁혀가는 방식으로 동작한다.", "이진 검색"},
                new String[]{"#1은 인접한 두 원소를 비교하여 정렬하는 알고리즘으로, 가장 큰 값이 맨 끝으로 이동하는 과정을 반복하여 정렬을 수행한다", "버블 정렬"},
                new String[]{"#1은 인덱스를 통해 빠른 접근이 가능하지만 크 기가 고정되어 있으며, 삽입, 삭제가 불편하다. #2는 포인터를 통해 다음 원소에 접근하며, 크기가 동적으로 변경이 가능하며 삽입, 삭제가 용이하지만, 인덱스를 통한 접근은 불가능하다.", "배열/리스트"},
                new String[]{"#1은 LIFO 구조로, 데이터를 삽입하거나 삭제할 때 가장 위에 있는 데이터를 조작한다. #2는 FIFO 구조로, 데이터를 삽입하거나 삭제할 때 가장 앞에 있는 데이터를 조작한다.", "스택/큐"},
                new String[]{"#1는 모든 노드의 왼쪽 서브트리에 있는 노드는 현재 노드보다 작은 값을 가지고, 오른쪽 서브트리에 있는 노드는 현재 노드보다 큰 값을 가지는 이진 트리이다.", "이진 탐색 트리"},
                new String[]{"#1는 암호화되지 않은 텍스트 데이터를 전송하는 프로토콜로, 데이터의 무결성이나 보안을 보장하지 않는다. #2는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화하여 전송하며, 데이터의 무결성과 보안을 보장한다", "HTTP/HTTPS"},
                new String[]{"#1는 실제 물리적인 메모리보다 큰 용량의 메모리 공간을 프로세스에 제공하는 기술이다.", "가상 메모리"},
                new String[]{"#1 알고리즘은 하나의 출발점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘이다. 각 정점마다 최단 거리를 저장하면서, 최소 거리를 가진 정점을 선택하고 해당 정점과 연결된 다른 정점들의 거리를 갱신하며 탐색한다.", "다익스트라"},
                new String[]{"#1은 웹페이지의 구조를 정의하고, #2는 웹페이지의 스타일을 정의한다.", "HTML/CSS"},
                new String[]{"#1은 데이터가 하나 이상의 열과 행의 테이블에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 사전 정의된 관계로 데이터를 구성하는 정보 모음이며, #2는 이를 관리하는 소프트웨어이다.", "RDB/RDBMS"},
                new String[]{"#1는 컴퓨터에서 기억, 해석, 연산, 제어라는 4대 주요 기능을 관할하는 장치를 말한다.", "CPU"},
                new String[]{"#1는 인터넷에서 데이터를 주고 받을 때 사용되는 TCP/IP 기반의 애플리케이션 계층 프로토콜로, 웹사이트를 구성하는 주요 요소 중 하나이다.", "HTTP"},
                new String[]{"#1는 제어 장치, 산술 논리 장치, 레지스터를 하나의 단일체 집적회로로 구성한 것을 의미하며, CPU, GPU, DSP 등이 포함된다.", "마이크로프로세서"},
                new String[]{"#1는 운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 사이의 인터페이스를 제공하며, 프로세스 관리, 메모리 관리, 파일 시스템, 입출력 등의 기능을 담당한다.", "커널"},
                new String[]{"#1은 HTML 문서의 객체 지향 표현이다. JavaScript를 사용하여 웹 페이지를 조작하는 데 사용되며, HTML 문서의 모든 요소에 대한 계층적인 트리 구조로 표현된다.", "DOM"},
                new String[]{"#1은 관계형 데이터베이스와 달리, 스키마 없이 데이터를 저장하고 검색하는 데이터베이스로, 대량의 데이터를 빠르게 처리할 수 있으며, 확장성이 높다.", "NoSQL(Database)"},
                new String[]{"#1는 운영체제에서 프로세스의 실행 순서를 관리하는 소프트웨어이다. #1는 CPU를 최대한 효율적으로 사용하기 위해, 각 프로세스에 CPU 자원을 할당하며 실행 순서를 결정한다.", "스케줄러"},
                new String[]{"#1은 데이터베이스에서 하나의 논리적인 작업 단위를 의미한다. 일련의 작업을 원자적으로 처리하고, 성공하면 데이터베이스에 반영하고 실패하면 롤백하여 이전 상태로 되돌린다.", "트랜잭션"},
                new String[]{"#1은 네트워크에서 노드 간 가장 짧은 경로를 찾는 데 사용되는 알고리즘을 말하며, Dijkstra 알고리즘, Bellman-Ford 알고리즘, A* 알고리즘 등이 있다.", "최단 경로 알고리즘"},
                new String[]{"#1은 네트워크에서 데이터를 전송할 경로를 결정하는 과정이며, 데이터가 목적지로 안전하고 효율적으로 전달될 수 있도록 합니다.", "라우팅"},
                new String[]{"#1은 클라이언트에서 초기 로드 시 서버에서 HTML을 생성하여 브라우저에 렌더링하는 방식으로, 초기 로딩 속도가 빠르고 검색 엔진 최적화(SEO)에 유리하다.", "서버사이드 렌더링"},
                new String[]{"#1은 JavaScript 비동기 처리 패턴 중 하나로, 비동기 처리의 결과 값을 다루기 위해 사용한다. 성공한 경우와 실패한 경우에 대한 처리를 각각 콜백 함수를 통해 작성해야 했던 기존의 콜백 헬 문제를 해결하기 위해 고안되었다.", "프로미스"},
                new String[]{"#1는 범용 고유 식별자로, 고유성을 보장하면서 생성할 수 있는 식별자이다. 대개 16진수 숫자 32자리로 표현되며, 주로 데이터베이스나 분산 시스템에서 데이터를 식별하기 위해 사용된다.", "UUID"},
                new String[]{"데이터베이스 설계에서, #1는 데이터의 무결성을 보장하기 위해 수행되며, #2는 퍼포먼스 향상, 데이터 관리의 용이 등의 목적으로 #1에 반해 수행된다.", "정규화/역정규화"},
                new String[]{"#1은 입출력 데이터를 처리하기 위한 일종의 통로를 역할을 하며, 데이터를 쓰거나 읽을 수 있는 연속적인 데이터 흐름을 의미한다.", "스트림"},
                new String[]{"#1은 한 번에 하나의 비트를 전송하는 방식으로, 병렬 방식보다는 전송 속도가 느리며, 전송 거리가 멀고 데이터 손실이 발생할 가능성이 높은 장비에서 사용된다.", "시리얼"},
                new String[]{"MVVM 디자인 패턴에서, #1는 어플리케이션에서 사용되는 데이터와 데이터 처리를 담당하고, #2는 사용자 인터페이스를 담당하며, #3는 #1와 #2 사이에서 상호작용을 담당한다.", "Model/View/ViewModel"},
                new String[]{"#1는 데이터베이스의 구조를 그래픽으로 나타낸 도구이다. #1는 업무 분석 과정에서 개발자와 사용자 사이의 의사소통을 돕고, 데이터베이스 설계를 위한 기반이 된다.", "ERD"});
    }
}
